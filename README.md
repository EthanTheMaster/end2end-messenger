# What is this?
This is a novel end-to-end encryption messaging service. Note that there is no guarantee that this service is resilient to any attacks of any kind. Use this service with caution if security is of the utmost importance. 
# Background
The backend is written in Rust and is handled by the `actix-web` library. Communication is done with WebSocket, and encryption/decryption is done completely within the client's web browser. The frontend uses the `CryptoJS` library to handle the AES-256 CBC encryption/decryption. 
# Getting Started Basics
To get the service running, you will need ports `80` and `8080` open and port forwarded. Port `80` is needed to get an SSL certificate and port `8080` is the (default) port of the chat service. You will also need to [install `cargo` and `rust`](https://doc.rust-lang.org/cargo/getting-started/installation.html). Get a domain name from [https://www.noip.com/](https://www.noip.com/) and make note of it. Point this domain name to your server's IP address. To get an SSL certificate, install `certbot` from the [Electronic Frontier Foundation's website](https://certbot.eff.org/instructions) and follow the instructions for your OS. Getting an SSL certificate should involve running `sudo certbot certonly --standalone`, typing in your noip domain, and waiting for `certbot` to complete the validation stage after spinning a webserver (it is mandatory that port 80 be opened). You may need to disable your firewall for this to work (eg. `sudo ufw disable`). Certbot should finish with a print out of the locations of the public and private keys. Delete the example keys (`*.pem`) from the project directory and run `cp` to copy the `cert.pem` (not `fullchain.pem`) and `privkey.pem`, that `certbot` created, into the project's directory. Edit `config.json` inside the project directory and change the properties `ip`, `private_key_path`, and `certificate_path` to your server's IP address, private key path, and certificate file path, respectively. Move/`cd` into the project directory and run `cargo run`. You may need to alter the permissions of the certificate and private key files to let the service read in the files. You can test your service by accessing the client via `https://yourdomain.com:8080` or via my [GitHub website (may be outdated)](https://ethanthemaster.github.io/end2end.html). The endpoint of the WebSocket service is `wss://yourdomain.com:8080/chat`. If you cannot connect, make sure your firewall is disabled either completely or for whatever port the service is running on.

The reason an SSL certificate from EFF is needed is that the browser may refuse to connect to an insecure WebSocket endpoint while on a secure website (eg. github.io). The browser may also refuse to open the camera (for the QR scan) if the server hosting the page is not secured. Furthermore, Safari will not connect to a WebSocket endpoint that has a self-signed certificate.